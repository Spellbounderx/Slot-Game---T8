using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class GameManager : MonoBehaviour
{
    [Header("Board Settings")]
    [SerializeField] private int boardHeight = 3;
    [SerializeField] private int boardWidth = 3;

    [Header("Slot Icons")]
    [SerializeField] private GameObject[] gamePieces;

    [Header("UI Elements")]
    [SerializeField] private Button spinButton;
    [SerializeField] private TMP_Text balanceText;
    [SerializeField] private TMP_Text betText;
    [SerializeField] private TMP_Text lastWinText;
    [SerializeField] private TMP_InputField betInput;

    [Header("Bankroll Settings")]
    [SerializeField] private int startingBalance = 1000;

    [Header("Animation Settings")]
    [SerializeField] private float spinTimePerReel = 1.0f;  // total spin duration per reel
    [SerializeField] private int scrollLoops = 5;            // number of times symbols loop

    private int balance;
    private int betAmount = 50;
    private int lastWin;
    private bool isSpinning = false;

    private GameObject _board;
    private GameObject[,] _gameBoard;
    private Transform[,] _gridSlots;
    private Vector3 _offset = new Vector3(0, 0, -1);
    private List<GameObject> _matchLines;

    void Awake()
    {
        if (spinButton != null)
        {
            spinButton.onClick.RemoveAllListeners();
            spinButton.onClick.AddListener(OnSpinButtonClicked);
        }
        else
            Debug.LogError("Spin button not assigned!");
    }

    void Start()
    {
        _board = GameObject.Find("GameBoard");
        if (_board == null) { Debug.LogError("GameBoard missing"); return; }

        _gameBoard = new GameObject[boardHeight, boardWidth];
        _gridSlots = new Transform[boardHeight, boardWidth];
        _matchLines = new List<GameObject>();

        for (int i = 0; i < boardHeight; i++)
            for (int j = 0; j < boardWidth; j++)
                _gridSlots[i, j] = _board.transform.Find($"{i},{j}");

        balance = startingBalance;
        lastWin = 0;

        UpdateBetFromInput();
        UpdateUI();
        InitializeBoard();
        UpdateSpinButton();
    }

    private void OnSpinButtonClicked()
    {
        if (isSpinning) return;
        if (balance < betAmount) return;

        UpdateBetFromInput();
        StartCoroutine(SpinRoutine());
    }

    private void UpdateBetFromInput()
    {
        if (betInput == null) return;

        int value;
        if (int.TryParse(betInput.text, out value))
            betAmount = Mathf.Clamp(value, 1, balance);
        else
            betAmount = 50;

        if (betText != null)
            betText.text = "Bet: " + betAmount;
    }

    private void InitializeBoard()
    {
        for (int i = 0; i < boardHeight; i++)
            for (int j = 0; j < boardWidth; j++)
                SpawnSymbol(i, j, immediate: true);
    }

    private IEnumerator SpinRoutine()
    {
        if (balance < betAmount) yield break;

        isSpinning = true;
        balance -= betAmount;
        UpdateUI();
        UpdateSpinButton();

        ClearMatchLines();

        // Spin each reel
        for (int col = 0; col < boardWidth; col++)
        {
            StartCoroutine(SpinReel(col));
            yield return new WaitForSeconds(0.2f); // stagger start of each reel
        }

        // Wait until all reels finish
        yield return new WaitForSeconds(spinTimePerReel + 0.5f);

        int payout = CheckCenterRow();
        if (payout > 0)
        {
            int winAmount = payout * betAmount;
            lastWin = winAmount;
            balance += winAmount;
        }

        UpdateUI();
        isSpinning = false;
        UpdateSpinButton();
    }

    private IEnumerator SpinReel(int col)
    {
        for (int loop = 0; loop < scrollLoops; loop++)
        {
            for (int row = 0; row < boardHeight; row++)
            {
                if (_gameBoard[row, col] != null) Destroy(_gameBoard[row, col]);
                SpawnSymbol(row, col);
            }
            yield return new WaitForSeconds(spinTimePerReel / scrollLoops);
        }
    }

    private void SpawnSymbol(int row, int col, bool immediate = false)
    {
        if (_gridSlots[row, col] == null || gamePieces.Length == 0) return;

        GameObject prefab = gamePieces[Random.Range(0, gamePieces.Length)];
        if (prefab == null) return;

        Vector3 pos = _gridSlots[row, col].position + _offset;
        GameObject obj = Instantiate(prefab, pos, Quaternion.identity, _gridSlots[row, col]);
        obj.name = prefab.name;
        _gameBoard[row, col] = obj;
    }

    private int CheckCenterRow()
    {
        int row = 1;
        if (_gameBoard[row, 0] == null || _gameBoard[row, 1] == null || _gameBoard[row, 2] == null)
            return 0;

        string n0 = _gameBoard[row, 0].name;
        string n1 = _gameBoard[row, 1].name;
        string n2 = _gameBoard[row, 2].name;

        if (n0 == n1 && n1 == n2)
        {
            DrawLine(_gameBoard[row, 0].transform.position + _offset,
                     _gameBoard[row, 2].transform.position + _offset);
            SymbolPrefab sym = _gameBoard[row, 0].GetComponent<SymbolPrefab>();
            return sym != null ? sym.symbolData.payout : 2;
        }
        return 0;
    }

    private void DrawLine(Vector3 start, Vector3 end)
    {
        GameObject line = new GameObject("WinLine");
        LineRenderer lr = line.AddComponent<LineRenderer>();
        lr.positionCount = 2;
        lr.SetPosition(0, start);
        lr.SetPosition(1, end);
        lr.startWidth = lr.endWidth = 0.1f;
        lr.material = new Material(Shader.Find("Sprites/Default"));
        lr.startColor = lr.endColor = Color.yellow;
        _matchLines.Add(line);
    }

    private void ClearMatchLines()
    {
        foreach (var l in _matchLines)
            if (l != null) Destroy(l);
        _matchLines.Clear();
    }

    private void UpdateUI()
    {
        if (balanceText != null) balanceText.text = "Balance: " + balance;
        if (betText != null) betText.text = "Bet: " + betAmount;
        if (lastWinText != null) lastWinText.text = "Last Win: " + lastWin;
    }

    private void UpdateSpinButton()
    {
        if (spinButton != null)
            spinButton.interactable = balance >= betAmount;
    }
}
